# -*- coding: utf-8 -*-
"""ProjekatIzRI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/128N0dunOr3VyJELMZpn80Q0Uy_xApRRf
"""

from google.colab import drive
drive.mount('/content/drive')

# !pip install tensorflow
# !pip install sklearn
# !pip install skimage
# !pip install colorama

import os
import tensorflow as tf
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
import cv2
import keras
import math
import numpy as np
from colorama import Fore, Style
from tensorflow.keras import datasets,models
from keras.models import Model
from keras import Sequential
from keras.layers import Convolution2D
import keras.backend as K
from keras.optimizers import Adam
from matplotlib import pyplot as plt
from skimage.metrics import structural_similarity as ssim

#poredimo tj racunamo slicnost izmedju slike A i slike B
# koristeci metriku MSE
# MSE - srednje kvadratna greska izmedju elemenata originalne slike A i
# i izoblicene slike B 
def mean_squared_error(imageA,imageB):
    res = np.power((imageA.astype('float') - imageB.astype('float')),2.)
    res = np.sum(res)
    w = imageA.shape[0]
    h = imageA.shape[1]
    return res/(w*h)
#koristeci psnr
#PSNR - Peak-signal-to-noise-ratio 
def psnr(y_true,y_pred):
    return -10*K.log(K.mean(K.flatten((y_true-y_pred))**2))/np.log(10)

def psnr1(imageA,imageB):
  mse = np.power(imageA.astype('float') - imageB.astype('float'),2)
  mse = np.mean(mse)
  if mse == 0:
    return 100
  return 20*math.log10(255.0/math.sqrt(mse))


def compare_images(imageA,imageB):
    scores = []
    scores.append(psnr(imageA,imageB))
    scores.append(mean_squared_error(imageA,imageB))
    # ssim  se koristi za poredjenje slicnosti izmedju 2 slike
    # ova mera je napravljena kako bi se unapredile tradicionalne metode za ocenu kvaliteta
    # slike kao sto su gore pomenute psnr i mse 
    # multichannel je ukljucen (True) kako bismo mogli raditi sa slikama koje imaju 3 kanala po pikselu(BGR ili RGB format)
    scores.append(ssim(imageA,imageB,multichannel=True))
    return scores

# arg. f-je je  faktor skaliranja slike
def prepare_image(path,factor):
    # prolazimo kroz direktorijum
    # u nasem slucaju taj direktorijum se nalazi na putanji 
    # drive/MyDrive/slike/Set14
    for file in os.listdir(path):
        # povratna vrednost f-je imread je slika koja je ucitana i nalazi se na
        # prosledjenoj putanji path/file 
        img = cv2.imread(path + '/' + file)
        # nakon ucitavanja ispisujemo dimenzije slike
        # ono sto odavde(ako ukljucimo stampanje) mozemo da vidimo je
        # da prvo ide sirina,pa visina,pa broj kanala,
        # nase slike su u boji tako da imamo 3 kanala
        # print('Image: {},dimension: {}'.format(file,img.shape))
    
        #visina,sirina i broj kanala 
        # originalne slike,a zatim i dimenzije modifikovane(sa faktorom umanjenja 
        # factor) slike
        height,width,_ = img.shape
        new_height = int(height/factor)
        new_width = int(width/factor)
        
        # f-ja resize se koristi za promenu velicine slike (sirina,visina)
        # prvo koristimo bilinearnu interpolaciju(ovo je po default-u te nisam morao postaviti parametar interpolation)
        img1 = cv2.resize(img,(new_width,new_height),interpolation = cv2.INTER_LINEAR)  
        img1 = cv2.resize(img1,(width,height),interpolation = cv2.INTER_LINEAR)
         
        # cuvamo modifikovane slike u direktorijumu slike1(rezultat primene bilinearne interpolacije)
        cv2.imwrite('drive/MyDrive/slike1/{}'.format(file),img1)
        
        # drugo koristimo bikubicnu interpolaciju
        img2 = cv2.resize(img,(new_width,new_height),interpolation = cv2.INTER_CUBIC)  
        img2 = cv2.resize(img2,(width,height),interpolation = cv2.INTER_CUBIC)

        cv2.imwrite('drive/MyDrive/slike2/{}'.format(file),img2)

def load_images(inputdir,inputpath):
  imglist = []
  img1list = []
  for i in range(len(inputpath)):
    img = cv2.imread(inputdir + inputpath[i],cv2.IMREAD_COLOR)
    img1 = cv2.imread(inputdir + inputpath[i],cv2.IMREAD_COLOR)

    img1 = cv2.resize(img,(64,64))
    img = cv2.resize(img1,(128,128))
    
    imglist.append(img)
    img1list.append(img1)
  return imglist,img1list

def main():
    prepare_image("drive/MyDrive/slike/Set5",3)  
  

if __name__ == "__main__":
    main()

# IMAGE_SIZE = 128
# CHANNELS = 3

def model(IMAGE_SIZE,CHANNELS):
    model = Sequential()
    model.add(Convolution2D(128,9,activation="relu",input_shape=(IMAGE_SIZE,IMAGE_SIZE,CHANNELS),padding="same"))
    model.add(Convolution2D(64,3,activation="relu",padding="same"))
    model.add(Convolution2D(3,5,activation="relu",padding="same"))
    return model

SRCNN = model(128,3)
# print(SRCNN.summary())

SRCNN1 = model(64,3)
# print(SRCNN1.summary())

image_path = sorted(os.listdir('drive/MyDrive/slike/General-100/General-100'))
image,image1 = load_images('drive/MyDrive/slike/General-100/General-100/',image_path)
image /= np.max(image)
image1 /= np.max(image1)

label = np.zeros((100,128,128,3),np.float32)
label1 = np.zeros((100,64,64,3),np.float32)
for i in range(image.shape[0]):
  temp = cv2.resize(image[i,:,:,:],(64,64))
  label1[i,:,:,:] = temp
  temp = cv2.resize(temp,(128,128))
  label[i,:,:,:]=temp
# print(label.shape)
# print(label1.shape)

initial_lerningrate = 2e-3

def ssim_loss(y_true, y_pred):
  return tf.reduce_mean(tf.image.ssim(y_true, y_pred, 2.0))


SRCNN.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
history = SRCNN.fit(label,image,epochs=100,batch_size=32,verbose=1)

SRCNN1.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
History = SRCNN1.fit(label1,image1,epochs=100,batch_size=32,verbose=1)

testImage_path = sorted(os.listdir('drive/MyDrive/slike/Set5'))
testImage,testImage1 = load_images('drive/MyDrive/slike/Set5/',testImage_path)

testImage /= np.max(testImage)
testImage1 /= np.max(testImage1)

result  = SRCNN.predict(testImage,batch_size=32)
result1 = SRCNN1.predict(testImage1,batch_size = 32)
# result.shape

print(Fore.BLUE + 'Poredjenje originalne slike i interpolirane(bikubicna interpolacija)')
for file in os.listdir('drive/MyDrive/slike2/'):
  imageA = cv2.imread('drive/MyDrive/slike2/{}'.format(file))
  imageB = cv2.imread('drive/MyDrive/slike/Set5/{}'.format(file))  
  Psnr = psnr1(imageA,imageB)
  Mse = mean_squared_error(imageA,imageB)
  SSIM = ssim(imageA,imageB,multichannel=True)

  fig = plt.figure()
  ax = fig.add_subplot(1, 2, 1)
  imgplot = plt.imshow(cv2.cvtColor(imageB,cv2.COLOR_BGR2RGB))
  ax.set_title('Referentna slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  
  ax = fig.add_subplot(1, 2, 2)
  imgplot = plt.imshow(cv2.cvtColor(imageA,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('Interpolirana slika\n(bikubiƒçna interpolacija)',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('file:{}\nPSNR:{}\nMSE:{}\nSSIM:{}\n'.format(file,Psnr,Mse,SSIM),fontdict={'fontweight': 'bold','color':'red'})

print(Fore.BLUE + 'Poredjenje originalne slike i interpolirane(bilinearna)')
for file in os.listdir('drive/MyDrive/slike1/'):
  imageA = cv2.imread('drive/MyDrive/slike1/{}'.format(file))
  imageB = cv2.imread('drive/MyDrive/slike/Set5/{}'.format(file))
  Psnr = psnr1(imageA,imageB)
  Mse = mean_squared_error(imageA,imageB)
  SSIM = ssim(imageA,imageB,multichannel=True)

  fig = plt.figure()
  ax = fig.add_subplot(1, 2, 1)
  imgplot = plt.imshow(cv2.cvtColor(imageB,cv2.COLOR_BGR2RGB))
  ax.set_title('Referentna slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  
  ax = fig.add_subplot(1, 2, 2)
  imgplot = plt.imshow(cv2.cvtColor(imageA,cv2.COLOR_BGR2RGB))
  imgplot.set_clim(0.0, 0.7)
  ax.set_title('Interpolirana slika\n(bilinearna interpolacija)',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('file:{}\nPSNR:{}\nMSE:{}\nSSIM:{}\n'.format(file,Psnr,Mse,SSIM),fontdict={'fontweight': 'bold','color':'red'})

print(Fore.BLUE + 'Poredjenje originalne slike i slike dobijene nakon primene SRCNN(9-3-5)')
i = 0
for i in range(5):
  imageA = result[i] 
  imageB = testImage[i].astype(np.float32)
  
  Psnr = psnr1(imageA,imageB)
  SSIM = ssim(imageA,imageB,multichannel=True)
  

  fig = plt.figure()
  ax = fig.add_subplot(1, 3, 1)
  imgplot = plt.imshow(cv2.cvtColor(imageB,cv2.COLOR_BGR2RGB))
  ax.set_title('Referentna slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  
  ax = fig.add_subplot(1, 3, 2)
  imgplot = plt.imshow(cv2.cvtColor(imageA,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('SRCNN(9-3-5) slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr,3),round(SSIM,3),round(Mse,3)),fontdict={'fontweight': 'bold','color':'red'})

  
  imageC = result1[i]
  imageD = testImage1[i]
  i+=1
  
  Psnr1 = psnr1(imageC,imageD)
  SSIM1 = ssim(imageC,imageD,multichannel=True)
  

  ax = fig.add_subplot(1, 3, 3)
  imgplot = plt.imshow(cv2.cvtColor(imageC,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('Slika velicine(64,64,3)',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr1,3),round(SSIM1,3)),fontdict={'fontweight': 'bold','color':'red'})
  plt.tight_layout()

def model1(IMAGE_SIZE,CHANNELS):
    model = Sequential([
                        Convolution2D(64,9,activation="gelu",input_shape=(IMAGE_SIZE,IMAGE_SIZE,CHANNELS),padding="same"),
                        Convolution2D(32,1,activation="gelu",padding="same"),
                        Convolution2D(16,1,activation="gelu",padding="same"),
                        Convolution2D(3,5,activation="gelu",padding="same")
                        ])
    return model

SRCNN = model1(128,3)
# print(SRCNN.summary())

SRCNN1 = model1(64,3)
# print(SRCNN1.summary())

SRCNN.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
history1 = SRCNN.fit(label,image,epochs=100,batch_size=32,verbose=1)

SRCNN1.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
History1 = SRCNN1.fit(label1,image1,epochs=100,batch_size=32,verbose=1)

result  = SRCNN.predict(testImage,batch_size=32)
result1 = SRCNN1.predict(testImage1,batch_size = 32)

print(Fore.BLUE + 'Poredjenje originalne slike i slike dobijene nakon primene SRCNN(9-1-1-5)')
i = 0
for i in range(5):
  imageA = result[i] 
  imageB = testImage[i].astype(np.float32)
  
  Psnr = psnr1(imageA,imageB)
  SSIM = ssim(imageA,imageB,multichannel=True)
  

  fig = plt.figure()
  ax = fig.add_subplot(1, 3, 1)
  imgplot = plt.imshow(cv2.cvtColor(imageB,cv2.COLOR_BGR2RGB))
  ax.set_title('Referentna slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  
  ax = fig.add_subplot(1, 3, 2)
  imgplot = plt.imshow(cv2.cvtColor(imageA,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('SRCNN(9-1-1-5) slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr,3),round(SSIM,3)),fontdict={'fontweight': 'bold','color':'red'})

  
  imageC = result1[i]
  imageD = testImage1[i]
  i+=1
  
  Psnr1 = psnr1(imageC,imageD)
  SSIM1 = ssim(imageC,imageD,multichannel=True)
  

  ax = fig.add_subplot(1, 3, 3)
  imgplot = plt.imshow(cv2.cvtColor(imageC,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('Slika velicine(64,64,3)',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr1,3),round(SSIM1,3)),fontdict={'fontweight': 'bold','color':'red'})
  plt.tight_layout()

def model2(IMAGE_SIZE,CHANNELS):
    model = Sequential()
    model.add(Convolution2D(64,9,activation="elu",input_shape=(IMAGE_SIZE,IMAGE_SIZE,CHANNELS),padding="same"))
    model.add(Convolution2D(32,1,activation="elu",padding="same"))
    model.add(Convolution2D(3,5,activation="elu",padding="same"))
    return model

SRCNN = model2(128,3)
# print(SRCNN.summary())

SRCNN1 = model2(64,3)
# print(SRCNN1.summary())

SRCNN.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
history2 = SRCNN.fit(label,image,epochs=100,batch_size=32,verbose=1)

SRCNN1.compile(loss="mean_squared_error",optimizer=Adam(initial_lerningrate),metrics=[psnr,ssim_loss])
History2 = SRCNN1.fit(label1,image1,epochs=100,batch_size=32,verbose=1)

result  = SRCNN.predict(testImage,batch_size=32)
result1 = SRCNN1.predict(testImage1,batch_size = 32)

plt.title(label = 'PSNR',fontdict={'family':'serif','color':'red','size':25})
plt.plot(history.epoch,history.history['psnr'])
plt.plot(history1.epoch,history1.history['psnr'])
plt.xlabel('EPOCHS',fontdict={'family':'serif','color':'red','size':15})
plt.ylabel('PSNR',fontdict={'family':'serif','color':'red','size':15})
plt.legend(['SRCNN (9-3-5)','SRCNN (9-1-1-5)'])
plt.show()

plt.title(label = 'SSIM_LOSS',fontdict={'family':'serif','color':'red','size':25})
plt.plot(history.epoch,history.history['ssim_loss'])
plt.plot(history1.epoch,history1.history['ssim_loss'])
plt.xlabel('EPOCHS',fontdict={'family':'serif','color':'red','size':15})
plt.ylabel('SSIM_LOSS',fontdict={'family':'serif','color':'red','size':15})
plt.legend(['SRCNN (9-3-5)','SRCNN (9-1-1-5)'])
plt.show()

plt.title(label = 'PSNR',fontdict={'family':'serif','color':'red','size':25})
plt.plot(history1.epoch,history1.history['psnr'])
plt.plot(history2.epoch,history2.history['psnr'])
plt.xlabel('EPOCHS',fontdict={'family':'serif','color':'red','size':15})
plt.ylabel('PSNR',fontdict={'family':'serif','color':'red','size':15})

plt.legend(['SRCNN (9-1-1-5)','SRCNN (9-1-5)'])

plt.title(label = 'SSIM_LOSS',fontdict={'family':'serif','color':'red','size':25})
plt.plot(history1.epoch,history1.history['ssim_loss'])
plt.plot(history2.epoch,history2.history['ssim_loss'])
plt.xlabel('EPOCHS',fontdict={'family':'serif','color':'red','size':15})
plt.ylabel('SSIM_LOSS',fontdict={'family':'serif','color':'red','size':15})
plt.legend(['SRCNN (9-1-1-5)','SRCNN (9-1-5)'])
plt.show()

print(Fore.BLUE + 'Poredjenje originalne slike i slike dobijene nakon primene SRCNN(9-1-5)')
i = 0
for i in range(5):
  imageA = result[i] 
  imageB = testImage[i].astype(np.float32)
  
  Psnr = psnr1(imageA,imageB)
  SSIM = ssim(imageA,imageB,multichannel=True)
  

  fig = plt.figure()
  ax = fig.add_subplot(1, 3, 1)
  imgplot = plt.imshow(cv2.cvtColor(imageB,cv2.COLOR_BGR2RGB))
  ax.set_title('Referentna slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  
  ax = fig.add_subplot(1, 3, 2)
  imgplot = plt.imshow(cv2.cvtColor(imageA,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('SRCNN(9-1-5) slika',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr,3),round(SSIM,3)),fontdict={'fontweight': 'bold','color':'red'})

  
  imageC = result1[i]
  imageD = testImage1[i]
  i+=1
  
  Psnr1 = psnr1(imageC,imageD)
  SSIM1 = ssim(imageC,imageD,multichannel=True)
  

  ax = fig.add_subplot(1, 3, 3)
  imgplot = plt.imshow(cv2.cvtColor(imageC,cv2.COLOR_BGR2RGB))
  # imgplot.set_clim(0.0, 0.7)
  ax.set_title('Slika velicine(64,64,3)',fontdict={'fontweight': 'bold','color':'red'})
  ax.set_xticks([])
  ax.set_yticks([])
  ax.set_xlabel('PSNR:{}\nSSIM:{}\n'.format(round(Psnr1,3),round(SSIM1,3)),fontdict={'fontweight': 'bold','color':'red'})
  plt.tight_layout()